---
phase: 01-nav-persistence
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - dist/core.js
  - dist/global.js
autonomous: false

must_haves:
  truths:
    - "Nav ScrollTriggers (hide-on-footer, backdrop-blur) survive across navigations and re-bind correctly"
    - "Menu toggle opens/closes correctly after any number of navigations"
    - "Escape key closes menu after any number of navigations"
    - "Menu does not re-initialize (no duplicate event listeners) after navigations"
    - "ScrollTrigger count remains stable across 10+ navigations (no leaks, no missing triggers)"
    - "Transition overlay columns animate correctly on every leave and enter"
  artifacts:
    - path: "dist/core.js"
      provides: "ScrollTrigger scoping that preserves nav/footer triggers, menu-safe lifecycle"
      contains: "killScrollTriggersIn"
    - path: "dist/global.js"
      provides: "Nav ScrollTrigger re-init with proper cleanup of stale triggers"
      contains: "initNavScrollTriggersOnce"
  key_links:
    - from: "killScrollTriggersIn()"
      to: "nav ScrollTriggers"
      via: "container.contains() check prevents killing triggers with targets outside container"
      pattern: "rootEl\\.contains"
    - from: "global.afterEnter()"
      to: "initNavScrollTriggersOnce()"
      via: "re-initializes nav triggers after killing stale ones"
      pattern: "initNavScrollTriggersOnce"
    - from: "menuInitOnce()"
      to: "WFApp._menuInited guard"
      via: "prevents duplicate menu initialization"
      pattern: "_menuInited"
---

<objective>
Ensure ScrollTrigger scoping preserves nav/footer triggers, menu remains functional across navigations, and verify the full persistence solution end-to-end.

Purpose: Plan 01 fixed DOM persistence. This plan addresses the second layer: ensuring the JavaScript behaviors attached to persistent elements (ScrollTriggers for nav hide/blur, menu GSAP timeline, Escape key handler) survive navigation and do not leak or duplicate. Also includes a human verification checkpoint to visually confirm the fix.

Output: Updated dist/core.js with refined ScrollTrigger scoping, updated dist/global.js with robust nav trigger re-init, plus visual confirmation that all persistence works.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-nav-persistence/01-RESEARCH.md
@.planning/phases/01-nav-persistence/01-01-SUMMARY.md
@dist/core.js
@dist/global.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden ScrollTrigger scoping and nav trigger lifecycle</name>
  <files>dist/core.js, dist/global.js</files>
  <action>
**In dist/core.js:**

1. **Verify killScrollTriggersIn() scoping (lines ~537-575)**: The existing implementation already checks `rootEl.contains(triggerEl)` and skips triggers whose animation targets are outside the container. This should correctly preserve nav/footer ScrollTriggers. However, there is a gap: nav ScrollTriggers use STRING selectors (`.content_wrap`, `.page_wrap`) as trigger elements, and the function resolves string triggers via `rootEl.querySelector(trig)`. Since `.content_wrap` and `.page_wrap` exist inside the container, they WILL resolve and the trigger WILL be killed -- but the ANIMATION TARGET is `.layout_nav_wrap` which is OUTSIDE the container. The existing code handles this via the animation target check at lines 560-568. Verify this path works correctly by tracing through the logic:
   - String trigger `.content_wrap` resolves inside container: YES
   - Animation target `.layout_nav_wrap` is outside container: YES, so `return` (keep trigger)
   - This is correct behavior. No code change needed here.

2. **Add a comment in killScrollTriggersIn** to document WHY nav triggers are preserved (for future maintainability):
   After the animation target check block (around line 568), add a comment:
   ```javascript
   // NOTE: This safely preserves nav/footer ScrollTriggers because their
   // animation targets (.layout_nav_wrap) live outside the container,
   // even though their trigger elements (.content_wrap, .page_wrap) are inside.
   ```

**In dist/global.js:**

3. **Fix nav ScrollTrigger cleanup in afterEnter() (lines ~969-980)**: The current code kills triggers by matching STRING trigger values `.content_wrap` and `.page_wrap`, then re-initializes. This works but is fragile -- it could accidentally kill non-nav triggers that use the same selector. Instead, tag nav ScrollTriggers with an identifier so they can be selectively killed:

   In `initNavScrollTriggersOnce()` (around line 574), modify the two `gsap.to()` calls to add an `id` to their scrollTrigger config:
   ```javascript
   // Hide nav when footer becomes visible
   window.gsap.to('.layout_nav_wrap', {
     y: '-100%',
     opacity: 0,
     ease: 'sine.inOut',
     scrollTrigger: {
       id: 'nav-hide-on-footer',  // ADD THIS
       trigger: '.content_wrap',
       start: 'bottom 85%',
       end: 'bottom 50%',
       scrub: false,
       toggleActions: 'play none none reverse'
     }
   });
   ```

   And for the backdrop blur trigger:
   ```javascript
   window.gsap.to('.layout_nav_wrap', {
     css: {
       backdropFilter: 'blur(3px)',
       webkitBackdropFilter: 'blur(3px)'
     },
     ease: 'sine.inOut',
     scrollTrigger: {
       id: 'nav-backdrop-blur',  // ADD THIS
       trigger: '.page_wrap',
       start: 'top top-=10',
       end: 'top 97%',
       toggleActions: 'play none none reverse',
       scrub: true
     }
   });
   ```

4. **Update afterEnter() nav trigger cleanup** (lines ~969-980) to use the IDs instead of matching trigger selectors:
   ```javascript
   // Kill stale nav ScrollTriggers before re-init (they reference old DOM positions)
   try {
     if (window.ScrollTrigger && typeof window.ScrollTrigger.getAll === 'function') {
       window.ScrollTrigger.getAll().forEach(function (t) {
         try {
           var id = t.vars && t.vars.id;
           if (id === 'nav-hide-on-footer' || id === 'nav-backdrop-blur') t.kill();
         } catch (_) {}
       });
     }
   } catch (_) {}
   ```

5. **Add guard against stale data-page attribute**: In `initNavScrollTriggersOnce()`, the backdrop blur check reads `document.body.getAttribute('data-page')`. After Barba navigation, this attribute may be stale (Barba doesn't update body attributes). Add data-page update right after the guard in initNavScrollTriggersOnce:
   ```javascript
   function initNavScrollTriggersOnce() {
     if (WFApp._navScrollTriggersInited) return;
     WFApp._navScrollTriggersInited = true;
     if (!window.gsap || !window.ScrollTrigger) return;

     // Update body data-page from current Barba namespace (Barba doesn't update body attrs)
     try {
       var currentContainer = document.querySelector('[data-barba="container"]');
       if (currentContainer) {
         var ns = currentContainer.getAttribute('data-barba-namespace');
         if (ns) document.body.setAttribute('data-page', ns.toLowerCase());
       }
     } catch (_) {}

     // ... rest of function unchanged
   ```

6. **Ensure menu does not re-initialize**: The menu system uses `WFApp._menuInited` guard in `menuInitOnce()`. Since `menuInitOnce()` is only called from `initOnce()` (which has its own `didInit` guard), the menu CANNOT double-initialize. Verify this is correct -- no code change needed, just trace the call path. The menu attaches event listeners to persistent DOM elements (`.nav_icon_wrap`) that survive across navigations. Escape key handler is on `document` (persists). This is all correct.
  </action>
  <verify>
Read dist/core.js and dist/global.js and confirm:
- killScrollTriggersIn has explanatory comment about nav trigger preservation
- initNavScrollTriggersOnce scrollTrigger configs include id fields
- afterEnter kills nav triggers by ID (not by trigger selector string)
- initNavScrollTriggersOnce updates body data-page from current container namespace
- Menu init guard (_menuInited) is intact and only called once path confirmed
  </verify>
  <done>
Nav ScrollTriggers are tagged with IDs for precise cleanup. afterEnter kills stale nav triggers by ID and re-inits with current page context. body[data-page] updated from Barba namespace. Menu initialization protected against duplication.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify nav persistence across navigations</name>
  <files>dist/core.js, dist/global.js</files>
  <action>
Deploy the updated dist/core.js and dist/global.js to a test environment (commit and push to GitHub, update jsDelivr hash in Webflow). This task is a human verification checkpoint -- the user tests the deployed changes in a live browser environment.
  </action>
  <verify>
User visually confirms all 5 test scenarios pass:
1. Hard page load shows nav/footer/overlay correctly (no flicker)
2. 10+ successive navigations keep nav/footer visible and overlay animating
3. Menu toggle and Escape-key close work after 3+ navigations
4. DevTools shows exactly 1 each of .layout_nav_wrap, .layout_transition_wrap, footer
5. ScrollTrigger.getAll().length remains stable after 10+ navigations
  </verify>
  <done>
User confirms all NAV-01 through NAV-05 requirements pass. No visual regression, no duplicate elements, no ScrollTrigger leaks.
  </done>
</task>

</tasks>

<verification>
Phase 1 is complete when:
- Nav bar persists across 10+ navigations (NAV-01)
- Menu toggle and Escape-key close work after any number of navigations (NAV-02)
- Footer persists without flicker (NAV-03)
- Initial hard load has no visual regression (NAV-04)
- Transition overlay columns animate correctly on every navigation (NAV-05)
- No ScrollTrigger leaks (count stable across navigations)
- No duplicate persistent DOM elements
</verification>

<success_criteria>
All 5 NAV requirements pass visual/functional testing by the user. ScrollTrigger count remains stable. Menu remains fully functional. No duplicate DOM elements accumulate.
</success_criteria>

<output>
After completion, create `.planning/phases/01-nav-persistence/01-02-SUMMARY.md`
</output>
